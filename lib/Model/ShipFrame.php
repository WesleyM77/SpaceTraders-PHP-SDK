<?php
/**
 * ShipFrame
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * SpaceTraders API
 *
 * SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: joel@spacetraders.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * ShipFrame Class Doc Comment
 *
 * @category Class
 * @description The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ShipFrame implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ShipFrame';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'symbol' => 'string',
        'name' => 'string',
        'description' => 'string',
        'condition' => 'int',
        'module_slots' => 'int',
        'mounting_points' => 'int',
        'fuel_capacity' => 'int',
        'requirements' => '\OpenAPI\Client\Model\ShipRequirements'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'symbol' => null,
        'name' => null,
        'description' => null,
        'condition' => null,
        'module_slots' => null,
        'mounting_points' => null,
        'fuel_capacity' => null,
        'requirements' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'symbol' => false,
        'name' => false,
        'description' => false,
        'condition' => false,
        'module_slots' => false,
        'mounting_points' => false,
        'fuel_capacity' => false,
        'requirements' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'symbol' => 'symbol',
        'name' => 'name',
        'description' => 'description',
        'condition' => 'condition',
        'module_slots' => 'moduleSlots',
        'mounting_points' => 'mountingPoints',
        'fuel_capacity' => 'fuelCapacity',
        'requirements' => 'requirements'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'symbol' => 'setSymbol',
        'name' => 'setName',
        'description' => 'setDescription',
        'condition' => 'setCondition',
        'module_slots' => 'setModuleSlots',
        'mounting_points' => 'setMountingPoints',
        'fuel_capacity' => 'setFuelCapacity',
        'requirements' => 'setRequirements'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'symbol' => 'getSymbol',
        'name' => 'getName',
        'description' => 'getDescription',
        'condition' => 'getCondition',
        'module_slots' => 'getModuleSlots',
        'mounting_points' => 'getMountingPoints',
        'fuel_capacity' => 'getFuelCapacity',
        'requirements' => 'getRequirements'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SYMBOL_PROBE = 'FRAME_PROBE';
    public const SYMBOL_DRONE = 'FRAME_DRONE';
    public const SYMBOL_INTERCEPTOR = 'FRAME_INTERCEPTOR';
    public const SYMBOL_RACER = 'FRAME_RACER';
    public const SYMBOL_FIGHTER = 'FRAME_FIGHTER';
    public const SYMBOL_FRIGATE = 'FRAME_FRIGATE';
    public const SYMBOL_SHUTTLE = 'FRAME_SHUTTLE';
    public const SYMBOL_EXPLORER = 'FRAME_EXPLORER';
    public const SYMBOL_MINER = 'FRAME_MINER';
    public const SYMBOL_LIGHT_FREIGHTER = 'FRAME_LIGHT_FREIGHTER';
    public const SYMBOL_HEAVY_FREIGHTER = 'FRAME_HEAVY_FREIGHTER';
    public const SYMBOL_TRANSPORT = 'FRAME_TRANSPORT';
    public const SYMBOL_DESTROYER = 'FRAME_DESTROYER';
    public const SYMBOL_CRUISER = 'FRAME_CRUISER';
    public const SYMBOL_CARRIER = 'FRAME_CARRIER';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSymbolAllowableValues()
    {
        return [
            self::SYMBOL_PROBE,
            self::SYMBOL_DRONE,
            self::SYMBOL_INTERCEPTOR,
            self::SYMBOL_RACER,
            self::SYMBOL_FIGHTER,
            self::SYMBOL_FRIGATE,
            self::SYMBOL_SHUTTLE,
            self::SYMBOL_EXPLORER,
            self::SYMBOL_MINER,
            self::SYMBOL_LIGHT_FREIGHTER,
            self::SYMBOL_HEAVY_FREIGHTER,
            self::SYMBOL_TRANSPORT,
            self::SYMBOL_DESTROYER,
            self::SYMBOL_CRUISER,
            self::SYMBOL_CARRIER,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('symbol', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('condition', $data ?? [], null);
        $this->setIfExists('module_slots', $data ?? [], null);
        $this->setIfExists('mounting_points', $data ?? [], null);
        $this->setIfExists('fuel_capacity', $data ?? [], null);
        $this->setIfExists('requirements', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['symbol'] === null) {
            $invalidProperties[] = "'symbol' can't be null";
        }
        $allowedValues = $this->getSymbolAllowableValues();
        if (!is_null($this->container['symbol']) && !in_array($this->container['symbol'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'symbol', must be one of '%s'",
                $this->container['symbol'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['description'] === null) {
            $invalidProperties[] = "'description' can't be null";
        }
        if (!is_null($this->container['condition']) && ($this->container['condition'] > 100)) {
            $invalidProperties[] = "invalid value for 'condition', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['condition']) && ($this->container['condition'] < 0)) {
            $invalidProperties[] = "invalid value for 'condition', must be bigger than or equal to 0.";
        }

        if ($this->container['module_slots'] === null) {
            $invalidProperties[] = "'module_slots' can't be null";
        }
        if (($this->container['module_slots'] < 0)) {
            $invalidProperties[] = "invalid value for 'module_slots', must be bigger than or equal to 0.";
        }

        if ($this->container['mounting_points'] === null) {
            $invalidProperties[] = "'mounting_points' can't be null";
        }
        if (($this->container['mounting_points'] < 0)) {
            $invalidProperties[] = "invalid value for 'mounting_points', must be bigger than or equal to 0.";
        }

        if ($this->container['fuel_capacity'] === null) {
            $invalidProperties[] = "'fuel_capacity' can't be null";
        }
        if (($this->container['fuel_capacity'] < 0)) {
            $invalidProperties[] = "invalid value for 'fuel_capacity', must be bigger than or equal to 0.";
        }

        if ($this->container['requirements'] === null) {
            $invalidProperties[] = "'requirements' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets symbol
     *
     * @return string
     */
    public function getSymbol()
    {
        return $this->container['symbol'];
    }

    /**
     * Sets symbol
     *
     * @param string $symbol Symbol of the frame.
     *
     * @return self
     */
    public function setSymbol($symbol)
    {
        if (is_null($symbol)) {
            throw new \InvalidArgumentException('non-nullable symbol cannot be null');
        }
        $allowedValues = $this->getSymbolAllowableValues();
        if (!in_array($symbol, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'symbol', must be one of '%s'",
                    $symbol,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['symbol'] = $symbol;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the frame.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Description of the frame.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets condition
     *
     * @return int|null
     */
    public function getCondition()
    {
        return $this->container['condition'];
    }

    /**
     * Sets condition
     *
     * @param int|null $condition Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
     *
     * @return self
     */
    public function setCondition($condition)
    {
        if (is_null($condition)) {
            throw new \InvalidArgumentException('non-nullable condition cannot be null');
        }

        if (($condition > 100)) {
            throw new \InvalidArgumentException('invalid value for $condition when calling ShipFrame., must be smaller than or equal to 100.');
        }
        if (($condition < 0)) {
            throw new \InvalidArgumentException('invalid value for $condition when calling ShipFrame., must be bigger than or equal to 0.');
        }

        $this->container['condition'] = $condition;

        return $this;
    }

    /**
     * Gets module_slots
     *
     * @return int
     */
    public function getModuleSlots()
    {
        return $this->container['module_slots'];
    }

    /**
     * Sets module_slots
     *
     * @param int $module_slots The amount of slots that can be dedicated to modules installed in the ship. Each installed module take up a number of slots, and once there are no more slots, no new modules can be installed.
     *
     * @return self
     */
    public function setModuleSlots($module_slots)
    {
        if (is_null($module_slots)) {
            throw new \InvalidArgumentException('non-nullable module_slots cannot be null');
        }

        if (($module_slots < 0)) {
            throw new \InvalidArgumentException('invalid value for $module_slots when calling ShipFrame., must be bigger than or equal to 0.');
        }

        $this->container['module_slots'] = $module_slots;

        return $this;
    }

    /**
     * Gets mounting_points
     *
     * @return int
     */
    public function getMountingPoints()
    {
        return $this->container['mounting_points'];
    }

    /**
     * Sets mounting_points
     *
     * @param int $mounting_points The amount of slots that can be dedicated to mounts installed in the ship. Each installed mount takes up a number of points, and once there are no more points remaining, no new mounts can be installed.
     *
     * @return self
     */
    public function setMountingPoints($mounting_points)
    {
        if (is_null($mounting_points)) {
            throw new \InvalidArgumentException('non-nullable mounting_points cannot be null');
        }

        if (($mounting_points < 0)) {
            throw new \InvalidArgumentException('invalid value for $mounting_points when calling ShipFrame., must be bigger than or equal to 0.');
        }

        $this->container['mounting_points'] = $mounting_points;

        return $this;
    }

    /**
     * Gets fuel_capacity
     *
     * @return int
     */
    public function getFuelCapacity()
    {
        return $this->container['fuel_capacity'];
    }

    /**
     * Sets fuel_capacity
     *
     * @param int $fuel_capacity The maximum amount of fuel that can be stored in this ship. When refueling, the ship will be refueled to this amount.
     *
     * @return self
     */
    public function setFuelCapacity($fuel_capacity)
    {
        if (is_null($fuel_capacity)) {
            throw new \InvalidArgumentException('non-nullable fuel_capacity cannot be null');
        }

        if (($fuel_capacity < 0)) {
            throw new \InvalidArgumentException('invalid value for $fuel_capacity when calling ShipFrame., must be bigger than or equal to 0.');
        }

        $this->container['fuel_capacity'] = $fuel_capacity;

        return $this;
    }

    /**
     * Gets requirements
     *
     * @return \OpenAPI\Client\Model\ShipRequirements
     */
    public function getRequirements()
    {
        return $this->container['requirements'];
    }

    /**
     * Sets requirements
     *
     * @param \OpenAPI\Client\Model\ShipRequirements $requirements requirements
     *
     * @return self
     */
    public function setRequirements($requirements)
    {
        if (is_null($requirements)) {
            throw new \InvalidArgumentException('non-nullable requirements cannot be null');
        }
        $this->container['requirements'] = $requirements;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


